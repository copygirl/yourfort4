// Generated by LiveScript 1.4.0
(function(){
  var Matrix, Shader, Program, Buffer, renderers, glUtils, Graphics;
  Matrix = require('sylvester').Matrix;
  Shader = require('./shader');
  Program = require('./program');
  Buffer = require('./buffer');
  renderers = require('./renderers');
  glUtils = require('./glUtils');
  module.exports = Graphics = (function(){
    Graphics.displayName = 'Graphics';
    var prototype = Graphics.prototype, constructor = Graphics;
    function Graphics(game, canvas, size, scale){
      this.game = game;
      this.canvas = canvas;
      size == null && (size = [450, 275]);
      scale == null && (scale = 2);
      this.gl = (function(){
        var ref$;
        try {
          return (ref$ = this.canvas.getContext('webgl')) != null
            ? ref$
            : this.canvas.getContext('experimental-webgl');
        } catch (e$) {}
      }.call(this));
      if (this.gl == null) {
        throw Error("Couldn't create WebGL context");
      }
      if (typeof WebGLDebugUtils != 'undefined' && WebGLDebugUtils !== null) {
        this.gl = WebGLDebugUtils.makeDebugContext(this.gl);
      }
      this.projMatrix = null;
      this.viewMatrix = Matrix.I(4);
      this.resize(size, scale);
      this.matrixStack = [];
      this.renderers = {
        sprite: new renderers.SpriteRenderer(this)
      };
    }
    Object.defineProperty(prototype, 'size', {
      get: function(){
        var ref$;
        return [(ref$ = this.canvas)['width'], ref$['height']];
      },
      set: function(size){
        this.resize(size(this.scale));
      },
      configurable: true,
      enumerable: true
    });
    Object.defineProperty(prototype, 'scale', {
      get: function(){
        return this.canvas.clientWidth / this.canvas.width;
      },
      set: function(scale){
        var ref$;
        this.resize([(ref$ = this.canvas)['width'], ref$['height']], scale);
      },
      configurable: true,
      enumerable: true
    });
    prototype.resize = function(size, scale){
      var ref$;
      (ref$ = this.canvas)['width'] = size[0], ref$['height'] = size[1];
      this.canvas.style.width = size[0] * scale + "px";
      this.canvas.style.height = size[1] * scale + "px";
      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      this.projMatrix = glUtils.makeOrtho(0, this.canvas.width, this.canvas.height, 0, -128, 128);
    };
    prototype.init = function(){
      var ref$, i$, ref1$, len$, uniform, attr;
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.program = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
  })(Program, [this].concat([(ref$ = this.game.assets.shaders)["default.vs"], ref$["default.fs"]]), function(){});
      this.program.use();
      for (i$ = 0, len$ = (ref1$ = ['uPMatrix', 'uMVMatrix', 'uColor', 'uSampler']).length; i$ < len$; ++i$) {
        uniform = ref1$[i$];
        this.program.uniform(uniform);
      }
      for (i$ = 0, len$ = (ref1$ = ['aVertexPosition', 'aTextureCoord']).length; i$ < len$; ++i$) {
        attr = ref1$[i$];
        this.program.attribute(attr);
      }
    };
    prototype.push = function(matrix){
      matrix == null && (matrix = this.viewMatrix.dup());
      this.matrixStack.push(this.viewMatrix);
      this.viewMatrix = matrix;
    };
    prototype.pop = function(){
      if (this.matrixStack.length <= 0) {
        throw new Error("Attempting to pop empty matrix stack");
      }
      return this.viewMatrix = this.matrixStack.pop();
    };
    prototype.render = function(){
      var id, ref$, entity, ref1$;
      this.gl.clearColor(0, 0, 0, 1);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      this.program.uniforms.uPMatrix.setf(this.projMatrix);
      this.program.uniforms.uMVMatrix.setf(this.viewMatrix);
      for (id in ref$ = this.game.entitiesRenderable) {
        entity = ref$[id];
        if ((ref1$ = this.renderers[entity.renderer]) != null) {
          ref1$.render(entity);
        }
      }
    };
    return Graphics;
  }());
}).call(this);
